---
# This CronJob addresses the following issue:
# https://github.com/goauthentik/authentik/issues/18915
apiVersion: batch/v1
kind: CronJob
metadata:
  name: authentik-task-cleanup
  namespace: authentik
spec:
  schedule: "*/15 * * * *" # Every 15 minutes
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        spec:
          restartPolicy: OnFailure
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            fsGroup: 1000
            seccompProfile:
              type: RuntimeDefault
          containers:
            - name: task-cleanup
              # renovate: datasource=docker registryUrl=https://ghcr.io depName=goauthentik/server
              image: ghcr.io/goauthentik/server:2025.12.0-rc3
              securityContext:
                readOnlyRootFilesystem: true
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                    - ALL
              command:
                - /bin/sh
                - -c
                - |
                  ak shell -c "
                  from authentik.tasks.models import Task
                  from django.db.models import Count
                  from django.utils import timezone
                  from datetime import timedelta

                  queued = Task.objects.filter(state='queued').count()
                  print(f'Total queued tasks: {queued}')

                  # Scheduled tasks that should only have 1 instance queued
                  SINGLETON_TASKS = [
                      'authentik.core.tasks.clean_expired_models',
                      'authentik.core.tasks.clean_temporary_users',
                      'authentik.admin.tasks.update_latest_version',
                      'authentik.blueprints.v1.tasks.blueprints_discovery',
                      'authentik.blueprints.v1.tasks.clear_failed_blueprints',
                      'authentik.crypto.tasks.certificate_discovery',
                      'authentik.outposts.tasks.outpost_service_connection_monitor',
                      'authentik.outposts.tasks.outpost_connection_discovery',
                  ]

                  # Dedupe singleton tasks - keep only the newest queued instance
                  total_deduped = 0
                  for actor in SINGLETON_TASKS:
                      queued_tasks = Task.objects.filter(state='queued', actor_name=actor).order_by('-mtime')
                      count = queued_tasks.count()
                      if count > 1:
                          newest = queued_tasks.first()
                          deleted, _ = Task.objects.filter(
                              state='queued',
                              actor_name=actor
                          ).exclude(message_id=newest.message_id).delete()
                          total_deduped += deleted
                          print(f'  {actor.split(\".\")[-1]}: {deleted} duplicates')
                  if total_deduped > 0:
                      print(f'Deduped {total_deduped} singleton tasks')

                  # Clear stale outpost tasks (older than 5 min) - these spam and regenerate
                  stale_threshold = timezone.now() - timedelta(minutes=5)
                  SPAMMY_TASKS = [
                      'authentik.outposts.tasks.outpost_send_update',
                      'authentik.outposts.tasks.outpost_controller',
                      'authentik.events.tasks.event_trigger_dispatch',
                  ]
                  stale_spammy = Task.objects.filter(
                      state='queued',
                      mtime__lt=stale_threshold,
                      actor_name__in=SPAMMY_TASKS
                  )
                  if stale_spammy.count() > 0:
                      deleted, _ = stale_spammy.delete()
                      print(f'Deleted {deleted} stale spammy tasks')

                  # NOTE: We intentionally do NOT have a nuclear option that deletes
                  # all stale tasks. Tasks like apply_blueprint are legitimate and
                  # just waiting their turn in the queue.

                  final = Task.objects.filter(state='queued').count()
                  print(f'Final queued: {final}')
                  "
              env:
                - name: AUTHENTIK_POSTGRESQL__HOST
                  value: authentik-postgres-rw.authentik.svc.cluster.local
                - name: AUTHENTIK_POSTGRESQL__PORT
                  value: "5432"
                - name: AUTHENTIK_POSTGRESQL__NAME
                  value: authentik
                - name: AUTHENTIK_POSTGRESQL__USER
                  valueFrom:
                    secretKeyRef:
                      name: authentik-secrets
                      key: username
                - name: AUTHENTIK_POSTGRESQL__PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: authentik-secrets
                      key: password
                - name: AUTHENTIK_SECRET_KEY
                  valueFrom:
                    secretKeyRef:
                      name: authentik-secrets
                      key: authentik-secret-key
              resources:
                requests:
                  cpu: 100m
                  memory: 512Mi
                limits:
                  cpu: 500m
                  memory: 1Gi
