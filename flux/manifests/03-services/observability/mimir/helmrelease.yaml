---
# yaml-language-server: $schema=https://raw.githubusercontent.com/fluxcd-community/flux2-schemas/main/helmrelease-helm-v2.json
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: mimir
  namespace: mimir-system
spec:
  interval: 5m
  chart:
    spec:
      chart: mimir-distributed
      # renovate: datasource=helm registryUrl=https://grafana.github.io/helm-charts depName=mimir-distributed
      version: "6.0.5"
      sourceRef:
        kind: HelmRepository
        name: grafana
        namespace: flux-system
      interval: 1m
  install:
    createNamespace: true
    remediation:
      retries: 3
  upgrade:
    remediation:
      retries: 3
    timeout: 10m

  # PostRenderer to patch Kafka StatefulSet podManagementPolicy to prevent immutable field changes
  # This maintains OrderedReady to avoid upgrade failures when chart changes to Parallel
  postRenderers:
    - kustomize:
        patches:
          - target:
              kind: StatefulSet
              name: mimir-kafka
            patch: |
              - op: replace
                path: /spec/podManagementPolicy
                value: OrderedReady

  # Pull values from 1Password secret
  valuesFrom:
    - kind: Secret
      name: mimir-secrets
      valuesKey: access-key-id
      targetPath: mimir.structuredConfig.blocks_storage.s3.access_key_id
    - kind: Secret
      name: mimir-secrets
      valuesKey: access-key-secret
      targetPath: mimir.structuredConfig.blocks_storage.s3.secret_access_key
    - kind: Secret
      name: mimir-secrets
      valuesKey: access-key-id
      targetPath: mimir.structuredConfig.ruler_storage.s3.access_key_id
    - kind: Secret
      name: mimir-secrets
      valuesKey: access-key-secret
      targetPath: mimir.structuredConfig.ruler_storage.s3.secret_access_key
    - kind: Secret
      name: mimir-secrets
      valuesKey: access-key-id
      targetPath: mimir.structuredConfig.alertmanager_storage.s3.access_key_id
    - kind: Secret
      name: mimir-secrets
      valuesKey: access-key-secret
      targetPath: mimir.structuredConfig.alertmanager_storage.s3.secret_access_key

  values:
    # Disable internal MinIO - using external MinIO
    minio:
      enabled: false

    # Configure Mimir for distributed mode
    global:
      clusterDomain: cluster.local
      dnsService: kube-dns
      dnsNamespace: kube-system

    # Configure replication for 2-replica setup
    mimir:
      structuredConfig:
        ingester:
          ring:
            replication_factor: 2

        # Global limits configuration
        limits:
          max_global_series_per_user: 1000000
          # Increase ingestion limits for high-volume metrics
          ingestion_rate: 100000
          ingestion_burst_size: 1000000
          # Increase query parallelism
          max_query_parallelism: 32

        # Configure external MinIO storage with separate buckets
        blocks_storage:
          backend: s3
          s3:
            endpoint: "storage.services.apocrathia.com:9000"
            insecure: true
            bucket_name: mimir-blocks
          # TSDB configuration to reduce local disk usage
          tsdb:
            retention_period: 2h # Reduced from default 13h to flush blocks faster
            ship_interval: 30s # Ship blocks to S3 every 30s instead of 1m
            close_idle_tsdb_timeout: 1h # Close inactive TSDBs faster
            wal_compression_enabled: true # Compress WAL to reduce disk usage

        ruler_storage:
          backend: s3
          s3:
            endpoint: "storage.services.apocrathia.com:9000"
            insecure: true
            bucket_name: mimir-ruler

        alertmanager_storage:
          backend: s3
          s3:
            endpoint: "storage.services.apocrathia.com:9000"
            insecure: true
            bucket_name: mimir-alertmanager

        # Disable usage stats to avoid S3 configuration conflicts
        usage_stats:
          enabled: false

    # Resource configuration for Mimir components
    ingester:
      replicas: 2
      zoneAwareReplication:
        enabled: false # Disable zone awareness for simpler setup
      resources:
        requests:
          cpu: 500m
          memory: 1Gi
        limits:
          cpu: 2000m
          memory: 4Gi
      persistentVolume:
        enabled: false

    distributor:
      resources:
        requests:
          cpu: 100m
          memory: 1Gi
        limits:
          cpu: 500m
          memory: 4Gi
      # Increase ingestion rate limits to handle high-volume metrics
      extraArgs:
        distributor.ingestion-rate-limit: "100000"
        distributor.ingestion-burst-size: "1000000"

    querier:
      resources:
        requests:
          cpu: 200m
          memory: 512Mi
        limits:
          cpu: 1000m
          memory: 2Gi

    store_gateway:
      replicas: 2
      zoneAwareReplication:
        enabled: false # Disable zone awareness for simpler setup
      resources:
        requests:
          cpu: 100m
          memory: 256Mi
        limits:
          cpu: 500m
          memory: 1Gi
      persistentVolume:
        enabled: false

    compactor:
      resources:
        requests:
          cpu: 100m
          memory: 256Mi
        limits:
          cpu: 500m
          memory: 1Gi
      persistentVolume:
        enabled: false

    kafka:
      persistence:
        enabled: true
        storageClassName: longhorn
        size: 20Gi
      resources:
        requests:
          cpu: 500m
          memory: 1Gi
        limits:
          cpu: 1000m
          memory: 2Gi
      # Override retention from default 24h to 2h
      # Kafka is just a buffer - data should be consumed quickly by ingesters and flushed to S3
      extraEnv:
        - name: KAFKA_LOG_RETENTION_HOURS
          value: "2"

    # Enable the proper gateway (not just nginx)
    gateway:
      enabled: true
      enabledNonEnterprise: true # Enable gateway for non-enterprise
      replicas: 1
      resources:
        requests:
          cpu: 50m
          memory: 128Mi
        limits:
          cpu: 200m
          memory: 512Mi

    # Disable nginx since we're using the gateway
    nginx:
      enabled: false

    # Alertmanager configuration - using S3 for storage, so no local persistence needed
    alertmanager:
      persistentVolume:
        enabled: false

    # Configure for remote write from Prometheus
    serviceMonitor:
      enabled: true
      interval: 30s

    # Rollout operator configuration
    # Setting fullnameOverride ensures the certificate includes the correct service name
    # (mimir-rollout-operator) instead of just 'rollout-operator'
    rollout_operator:
      enabled: true
      fullnameOverride: mimir-rollout-operator
